steps:
  # Build the Docker image for ai-dmsp-api
  - id: docker build ai-dmsp-api
    name: "gcr.io/cloud-builders/docker"
    args:
      [
        "build",
        "-t",
        "us-west4-docker.pkg.dev/$PROJECT_ID/ai-dmsp-api-repo/ai-dmsp-api-image:$BUILD_ID",
        ".",
      ]
    env: ['DOCKER_BUILDKIT=1']
    dir: 'api'

  # Push the image to Artifact Registry
  - id: docker push ai-dmsp-api
    name: "gcr.io/cloud-builders/docker"
    args: ["push", "us-west4-docker.pkg.dev/$PROJECT_ID/ai-dmsp-api-repo/ai-dmsp-api-image:$BUILD_ID"]

  # Set image tag
  - id: update Kubernetes ai-dmsp-api Container Image
    name: "gcr.io/$PROJECT_ID/kustomize:${_KUSTOMIZE_VERSION}"
    entrypoint: bash
    args:
      - "-c"
      - |
        cd /workspace/k8s-manifests/${_KUST_BUILD_DIR}
        kustomize edit set image ai-dmsp-api-image=us-west4-docker.pkg.dev/$PROJECT_ID/ai-dmsp-api-repo/ai-dmsp-api-image:$BUILD_ID
    env:
      - "APPLY=true"
      - "CLOUDSDK_COMPUTE_ZONE=${_GKE_LOCATION}"
      - "CLOUDSDK_CONTAINER_CLUSTER=${_GKE_CLUSTER}"
      - "GCLOUD_PROJECT=$PROJECT_ID"

  # Build the Docker image for ai-dmsp react
  - id: docker build ai-dmsp-react
    name: 'gcr.io/cloud-builders/docker'
    entrypoint: 'bash'
    args:
      [
        '-c',
        'docker build --build-arg NPM_TOKEN=$$NPM_TOKEN -t us-west4-docker.pkg.dev/$PROJECT_ID/ai-dmsp-react-repo/ai-dmsp-react-image:$BUILD_ID .',
      ]
    env: [
      'DOCKER_BUILDKIT=1',
      'VITE_BACKEND_DOMAIN=api.dmsp.ai.dev.rtd.asu.edu',
      'VITE_BACKEND_PORT=443'
    ]
    secretEnv: ['NPM_TOKEN']
    dir: 'react'

  # Push the image to Artifact Registry
  - id: docker push ai-dmsp-react
    name: "gcr.io/cloud-builders/docker"
    args: ["push", "us-west4-docker.pkg.dev/$PROJECT_ID/ai-dmsp-react-repo/ai-dmsp-react-image:$BUILD_ID"]

  # Set image tag
  - id: update Kubernetes ai-dmsp-react Container Image
    name: "gcr.io/$PROJECT_ID/kustomize:${_KUSTOMIZE_VERSION}"
    entrypoint: bash
    args:
      - "-c"
      - |
        cd /workspace/k8s-manifests/${_KUST_BUILD_DIR}
        kustomize edit set image ai-dmsp-react-image=us-west4-docker.pkg.dev/$PROJECT_ID/ai-dmsp-react-repo/ai-dmsp-react-image:$BUILD_ID
    env:
      - "APPLY=true"
      - "CLOUDSDK_COMPUTE_ZONE=${_GKE_LOCATION}"
      - "CLOUDSDK_CONTAINER_CLUSTER=${_GKE_CLUSTER}"
      - "GCLOUD_PROJECT=$PROJECT_ID"


  # Trivy - AI-DMSP API
  - id: scan api image
    name: "aquasec/trivy:latest"
    args:
      - image
      - --severity=CRITICAL
      - --format=json
      - --output=/workspace/trivy-api-results.json
      - us-west4-docker.pkg.dev/$PROJECT_ID/ai-dmsp-api-repo/ai-dmsp-api-image:$BUILD_ID


  # Trivy - AI_DMSP React
  - id: scan react image
    name: "aquasec/trivy:latest"
    args:
      - image
      - --severity=CRITICAL
      - --format=json
      - --output=/workspace/trivy-react-results.json
      - us-west4-docker.pkg.dev/$PROJECT_ID/ai-dmsp-react-repo/ai-dmsp-react-image:$BUILD_ID


  # Slack - Trivy results
  - id: scan images
    name: "ubuntu"
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        apt-get update && apt-get install -y jq curl

        # Define array for image names
        IMAGES=("api" "react")

        for IMAGE in "${IMAGES[@]}"; do

          # Check for CRITICAL vulnerabilities
          if jq '.Results[] | select(.Vulnerabilities != null) | .Vulnerabilities[] | select(.Severity == "CRITICAL")' /workspace/trivy-$$IMAGE-results.json | grep -q '.';
          then
            # Header for critical vulnerabilities
            header=":warning: *CRITICAL vulnerabilities found in image:* AI-DMSP - $$IMAGE - ${_ENVIRONMENT}"
            blocks='[
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "'"${header}"'"
                }
              },
              {
                "type": "divider"
              }
            ]'

            # Extract vulnerabilities and format each entry
            vulns=$(jq -r '.Results[] | select(.Vulnerabilities != null) | .Vulnerabilities[] | select(.Severity == "CRITICAL") |
                    [ .VulnerabilityID, .PkgName, .InstalledVersion, .Severity ] | @tsv' /workspace/trivy-$$IMAGE-results.json)

            while IFS=$'\t' read -r vuln_id pkg_name installed_version severity; do
              # Combine vulnerability ID and severity
              vuln_info="${vuln_id} (${severity})"
              
              # Combine package name and version
              package_info="${pkg_name}:${installed_version}"
              
              # Add block for each vulnerability
              block_content=$(cat <<EOF
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Vulnerability & Severity:*\n\`$vuln_info\`"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Package & Version:*\n\`$package_info\`"
                  }
                ]
              },
              {
                "type": "divider"
              }
        EOF
              )
              blocks=$(echo "${blocks}" | jq ". += [$block_content]")
            done <<< "$vulns"

            # Send the detailed message to Slack
            curl -X POST -H 'Content-type: application/json' \
              --data "{\"blocks\": ${blocks}}" \
              ${_SLACK_WEBHOOK};
          else
            # Message when no CRITICAL vulnerabilities are found
            message=":white_check_mark: *No CRITICAL vulnerabilities found in image:* AI-DMSP - $$IMAGE - ${_ENVIRONMENT}"
            curl -X POST -H 'Content-type: application/json' \
              --data "{\"text\": \"$message\"}" \
              ${_SLACK_WEBHOOK};
          fi
        done



  # Copy secrets and SSL certificate files from secret manager
  - id: load kubernetes secrets file
    name: gcr.io/cloud-builders/gcloud
    entrypoint: "bash"
    args:
      - "-c"
      - |
        [[ -d "/workspace/k8s-manifests/${_KUST_BUILD_DIR}/secrets" ]] || mkdir /workspace/k8s-manifests/${_KUST_BUILD_DIR}/secrets
        gcloud secrets versions access latest --secret=${_SSL_CERT_SECRET_FILE} > /workspace/k8s-manifests/${_KUST_BUILD_DIR}/tls.crt
        gcloud secrets versions access latest --secret=${_SSL_KEY_SECRET_FILE} > /workspace/k8s-manifests/${_KUST_BUILD_DIR}/tls.key
        gcloud secrets versions access latest --secret=${_KUST_SECRET_FILE} > /workspace/k8s-manifests/${_KUST_BUILD_DIR}/secrets/kustomization.yaml

  # Deploy to the cluster
  - id: deploy ai-dmsp
    name: "gcr.io/$PROJECT_ID/kustomize:${_KUSTOMIZE_VERSION}"
    dir: "k8s-manifests"
    args:
      - "build"
      - "${_KUST_BUILD_DIR}"
    env:
      - "APPLY=true"
      - "CLOUDSDK_COMPUTE_ZONE=${_GKE_LOCATION}"
      - "CLOUDSDK_CONTAINER_CLUSTER=${_GKE_CLUSTER}"
      - "GCLOUD_PROJECT=$PROJECT_ID"

  # Ensure Workload Identity permissions are in place correctly
  - id: Setup workload identity permissions
    name: "gcr.io/cloud-builders/gcloud"
    entrypoint: "bash"
    args:
      - -c
      - |
        gcloud container clusters get-credentials ${_GKE_CLUSTER} --region ${_GKE_LOCATION} --project ${PROJECT_ID} && \
        ./workload-identity-setup.sh
    env:
      - "PROJECT_ID=${PROJECT_ID}"
      - "_GSA_NAME=${_GSA_NAME}"
      - "_KSA_NAME=${_KSA_NAME}"
      - "_GKE_NAMESPACE_NAME=${_GKE_NAMESPACE_NAME}"

availableSecrets:
  secretManager:
  - versionName: projects/$PROJECT_ID/secrets/dev-ai-dmsp-secret-npmrc-token/versions/latest
    env: 'NPM_TOKEN'
